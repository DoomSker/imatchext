#include "phrasesgen.h"
#include "natives.h"
#include "../IMatchExtInterface.h"
#include "extension.h"

#include <cstdio>
#include <iomanip>

extern IMatchFramework* g_pMatchFramework;
extern IMatchExtL4D* g_pMatchExtL4D;

ConVar sm_imatchext_gen_lang("sm_imatchext_gen_lang", "", 0, "Enforce only specific language to be parsed");

void CreateDirHierarchy(const char* pszPath)
{
	char szPathOnly[PLATFORM_MAX_PATH];
	V_strncpy(szPathOnly, pszPath, sizeof(szPathOnly));
	V_StripFilename(szPathOnly);
	g_pFullFileSystem->CreateDirHierarchy(szPathOnly);
}

const char* ConvertKeyToLowerCase(const char* pszIn)
{
	static char s_key[MAX_KEY_LENGTH];
	static const char* const pszLast = s_key + sizeof(s_key) - 1;

	char* pszOut = s_key;
	while (*pszIn != '\0' && pszOut != pszLast) {
		*(pszOut++) = (char)tolower(*(pszIn++));
	}

	*pszOut = '\0';
	return s_key;
}

void CPhrasesGenerator::SDK_OnUnload()
{
	if (m_pThread != NULL) {
		// We can't quit yet - notify a thread about unloading
		m_bReqTerm = true;
		m_pThread->WaitForThread();
		m_bReqTerm = false;
	}
}

ParseAction_t CPhrasesGenerator::State_EnteredSection(const char* pszKey)
{
	if (m_nSection == Section_None && V_stricmp(pszKey, "lang") == 0) {
		m_nSection = Section_Settings;
	}
	else if (m_nSection == Section_Settings && V_stricmp(pszKey, "tokens") == 0) {
		m_nSection = Section_Tokens;
	}

	return Parse_Continue;
}

ParseAction_t CPhrasesGenerator::State_KeyValue(const char* pszKey, const char* const pszValue)
{
	if (m_nSection != Section_Tokens) {
		return Parse_Continue;
	}

	// Ignore phrases in non-english files that contain original line
	if (!m_bEnglishFile && V_strnicmp(pszKey, "[english]", 9) == 0) {
		return Parse_Continue;
	}

	// Convert key to lower case
	const char* pszFixedKey = ConvertKeyToLowerCase(pszKey);
	if (m_Tokens.find(pszFixedKey) == m_Tokens.end()) {
		return Parse_Continue;
	}

	m_Out
		//<< "\t// Token: \"" << pszKey << "\"\n"
		<< "\t\"" << pszFixedKey << "\"\n"
		<< "\t{\n";

	const char* pch = pszValue;
	if (m_bEnglishFile) {
		// Look out for "%sN" and place #format replacements
		bool bHadFormat = false;
		
		while (*pch != '\0') {
			char ch = *(pch++);
			if (ch == '%' && *pch == 's' && isdigit(*(pch + 1)) != 0) {
				if (bHadFormat) {
					m_Out << ",{" << *(pch + 1) << ":s}";
				}
				else {
					bHadFormat = true;
					m_Out << "\t\t\"#format\"\t\"{" << *(pch + 1) << ":s}";
				}

				pch += 2;
			}
		}

		if (bHadFormat) {
			m_Out << "\"\n";
		}

		pch = pszValue;
	}

	m_Out
		<< "\t\t\"" << m_pszLangCode << "\"\t\t\"";

	// Escape some special characters
	while (*pch != '\0') {
		char ch = *(pch++);
		if (ch == '\n') {
			m_Out << "\\n";
		}
		else if (ch == '\v') {
			m_Out << "\\v";
		}
		else if (ch == '\r') {
			m_Out << "\\r";
		}
		else if (ch == '\t') {
			m_Out << "\\t";
		}
		else if (ch == '\f') {
			m_Out << "\\f";
		}
		else if (ch == '"') {
			m_Out << "\\\"";
		}
		else if (ch == '%' && *pch == 's' && isdigit(*(pch + 1)) != 0) {
			m_Out << '{' << *(pch + 1) << '}';
			pch += 2;
		}
		else {
			m_Out << ch;
		}
	}
	
	m_Out << "\"\n"
		<< "\t}\n"
		<< "\n";

	m_nParsed++;
	return Parse_Continue;
}

void CPhrasesGenerator::State_Ended(bool halted, bool failed)
{
	DevMsg("\tParsed %u out of %u\n", m_nParsed, m_Tokens.size());

	m_Out
		<< "\t// " << m_nParsed << " phrases\n";
}

void CPhrasesGenerator::RunThread(IThreadHandle* pHandle)
{
	m_tmBegin = std::chrono::high_resolution_clock::now();

	char szTempPath[PLATFORM_MAX_PATH];
	smutils->BuildPath(Path_SM, szTempPath, sizeof(szTempPath), "data/imatchext/phrases.tmp.txt");
	CreateDirHierarchy(szTempPath);

	for (auto& lang : m_Languages) {
		const char* pszLanguage = lang.second.c_str();
		m_bEnglishFile = V_stricmp(pszLanguage, "english") == 0;
		m_pszLangCode = lang.first.c_str();

		DevMsg("Processing '%s' \"%s\"\n", m_pszLangCode, pszLanguage);

		m_nParsed = 0;
		m_nSection = Section_None;

		m_Out.open(szTempPath);
		if (!m_Out.is_open()) {
			DevMsg("Unable to open temp file \"%s\"\n", szTempPath);
			break;
		}

		std::time_t now = std::time(NULL);

		m_Out
			<< "// Generated by imatchext\n"
			<< "// " << std::put_time(std::localtime(&now), "%c %Z") << "\n"
			<< "\n"
			<< "\"Phrases\"\n"
			<< "{\n";

		ParseTokensFromFile("l4d360ui", pszLanguage);
#if SOURCE_ENGINE == SE_LEFT4DEAD2
		ParseTokensFromFile("l4d360ui_tu", pszLanguage);
#endif

		m_Out << "}\n";
		m_Out.close();

		if (m_bReqTerm) {
			// Remove temp file
			unlink(szTempPath);
			break;
		}

		if (m_nParsed == 0) {
			continue;
		}

		char szActualPath[PLATFORM_MAX_PATH];
		if (m_bEnglishFile) {
			smutils->BuildPath(Path_SM, szActualPath, sizeof(szActualPath), "data/imatchext/translations/imatchext.phrases.txt");
		}
		else {
			smutils->BuildPath(Path_SM, szActualPath, sizeof(szActualPath), "data/imatchext/translations/%s/imatchext.phrases.txt", m_pszLangCode);
			CreateDirHierarchy(szActualPath);
		}

		if (g_pFullFileSystem->FileExists(szActualPath)) {
			g_pFullFileSystem->RemoveFile(szActualPath);
		}

		extern IFileSystem* g_pFullFileSystem;
		if (!g_pFullFileSystem->RenameFile(szTempPath, szActualPath)) {
			DevWarning("Unable to move file \"%s\" to \"%s\"\n", szTempPath, szActualPath);
			continue;
		}
	}

	m_Languages.clear();
	m_Tokens.clear();
}

void CPhrasesGenerator::OnTerminate(IThreadHandle* pHandle, bool cancel)
{
	auto now = std::chrono::high_resolution_clock::now();
	Msg("Generated translations in \"data/imatchext/translations/\" (%ums)\n", std::chrono::duration_cast<std::chrono::milliseconds>(now - m_tmBegin).count());

	m_pThread = NULL;
}

void CPhrasesGenerator::Generate()
{
	if (m_pThread != NULL) {
		Msg("Operation in progress\n");
		return;
	}

	if (g_pLanguageFileParser == NULL) {
		Msg("Requires langparser.ext\n");
		return;
	}

	BuildTokenList();

	const char* pszOnlyLang = sm_imatchext_gen_lang.GetString();

	size_t count = translator->GetLanguageCount();
	for (size_t n = 0; n < count; n++) {
		const char* pszLangCode = NULL;
		const char* pszLangName = NULL;

		if (!translator->GetLanguageInfo(n, &pszLangCode, &pszLangName)) {
			continue;
		}

		if (*pszOnlyLang == '\0' || V_stricmp(pszLangName, pszOnlyLang) == 0) {
			m_Languages.emplace_back(pszLangCode, pszLangName);
			if (*pszOnlyLang != '\0') {
				break;
			}
		}
	}

	if (m_Languages.size() == 0) {
		Msg("No languages found\n");
		return;
	}

	Msg("Generating phrases for %u languages\n", m_Languages.size());
	m_pThread = threader->MakeThread(this, NULL);
}

bool CPhrasesGenerator::AddToken(const char* pszToken)
{
	if (*pszToken == '#') {
		pszToken++;
	}

	if (*pszToken == '\0') {
		return false;
	}

	// Convert key to lower case
	m_Tokens.emplace(ConvertKeyToLowerCase(pszToken));
	return true;
}

void CPhrasesGenerator::BuildTokenList()
{
	m_Tokens.clear();

	KeyValues* pkvMission = g_pMatchExtL4D->GetAllMissions();
	if (pkvMission != NULL) {
		pkvMission = pkvMission->GetFirstTrueSubKey();
	}

	for (; pkvMission != NULL; pkvMission = pkvMission->GetNextTrueSubKey()) {
		AddToken(pkvMission->GetString("DisplayTitle"));
		AddToken(pkvMission->GetString("Description"));
		AddToken(pkvMission->GetString("poster/posterTitle"));
		AddToken(pkvMission->GetString("poster/posterTagline"));

		KeyValues* pkvMode = pkvMission->FindKey("modes");
		if (pkvMode != NULL) {
			pkvMode = pkvMode->GetFirstTrueSubKey();
		}

		for (; pkvMode != NULL; pkvMode = pkvMode->GetNextTrueSubKey()) {
			for (KeyValues* pkvChapter = pkvMode->GetFirstTrueSubKey(); pkvChapter != NULL; pkvChapter = pkvChapter->GetNextTrueSubKey()) {
				AddToken(pkvChapter->GetString("DisplayName"));
			}
		}
	}

#if SOURCE_ENGINE == SE_LEFT4DEAD2
	KeyValues* pkvMode = g_pMatchExtL4D->GetAllModes();
	if (pkvMode != NULL) {
		pkvMode = pkvMode->GetFirstTrueSubKey();
	}

	for (; pkvMode != NULL; pkvMode = pkvMode->GetNextTrueSubKey()) {
		const char* pszMode = pkvMode->GetName();
#else
	static const char* const s_L4D1Modes[] =
	{
		"coop",
		"versus",
		"teamversus",
		"survival",
	};

	for (auto pszMode : s_L4D1Modes) {
#endif
		char key[MAX_KEY_LENGTH];
		V_snprintf(key, sizeof(key), "L4D360UI_Lobby_Title_%s", pszMode);
		AddToken(key);

		V_snprintf(key, sizeof(key), "L4D360UI_Mode_%s", pszMode);
		AddToken(key);

		V_snprintf(key, sizeof(key), "L4D360UI_ModeCaps_%s", pszMode);
		AddToken(key);

#if SOURCE_ENGINE == SE_LEFT4DEAD2
		V_snprintf(key, sizeof(key), "L4D360UI_Mode_verbose_%s", pszMode);
		AddToken(key);

		V_snprintf(key, sizeof(key), "L4D360UI_Difficulty_Easy_%s", pszMode);
		AddToken(key);

		V_snprintf(key, sizeof(key), "L4D360UI_Difficulty_Normal_%s", pszMode);
		AddToken(key);

		V_snprintf(key, sizeof(key), "L4D360UI_Difficulty_Hard_%s", pszMode);
		AddToken(key);

		V_snprintf(key, sizeof(key), "L4D360UI_Difficulty_Impossible_%s", pszMode);
		AddToken(key);

		V_snprintf(key, sizeof(key), "L4D360UI_%s_Component", pszMode);
		AddToken(key);
	}
#else // MSVC19 doesn't recognize this method otherwise
	}
#endif

	// Misc. phrases
	AddToken("L4D360UI_Difficulty_Easy");
	AddToken("L4D360UI_Difficulty_Normal");
	AddToken("L4D360UI_Difficulty_Hard");
	AddToken("L4D360UI_Difficulty_Expert");
	AddToken("L4D360UI_Difficulty_Impossible");

#if SOURCE_ENGINE == SE_LEFT4DEAD2
	AddToken("L4D360UI_Difficulty_Easy_addon");
	AddToken("L4D360UI_Difficulty_Normal_addon");
	AddToken("L4D360UI_Difficulty_Hard_addon");
	AddToken("L4D360UI_Difficulty_Expert_addon");
	AddToken("L4D360UI_Difficulty_Impossible_addon");

	AddToken("L4D360UI_CampaignName_Unknown");
	AddToken("L4D360UI_LevelName_Unknown");
#endif

	AddToken("L4D360UI_Chapter_Any");
	AddToken("L4D360UI_Campaign");
	AddToken("L4D360UI_Campaign_Custom");
	AddToken("L4D360UI_Any");
	AddToken("L4D360UI_Scenario");
	AddToken("L4D360UI_Difficulty");
	AddToken("L4D360UI_Game");
	AddToken("L4D360UI_Random");

	AddToken("L4D360UI_Mode_Campaign");

	AddToken("L4D360UI_NamVet");
	AddToken("L4D360UI_TeenGirl");
	AddToken("L4D360UI_Biker");
	AddToken("L4D360UI_Manager");
#if SOURCE_ENGINE == SE_LEFT4DEAD2
	AddToken("L4D360UI_Mechanic");
	AddToken("L4D360UI_Coach");
	AddToken("L4D360UI_Producer");
	AddToken("L4D360UI_Gambler");
#endif

	AddToken("L4D360UI_Boomer");
	AddToken("L4D360UI_Hunter");
	AddToken("L4D360UI_Smoker");

	AddToken("L4D360UI_Survivors");
	AddToken("L4D360UI_Infected");
	AddToken("L4D360UI_Spectator");

	AddToken("L4D360UI_Player");

	AddToken("L4D360UI_BootPlayer");
	AddToken("L4D360UI_ChangeScenario");
	AddToken("L4D360UI_ReturnToLobby");
	AddToken("L4D360UI_ChangeDifficulty");
	AddToken("L4D360UI_RestartScenario");
	AddToken("L4D360UI_StartNewCampaign");
	AddToken("L4D360UI_RestartChapter");

	DevMsg("Inserted %u tokens\n", m_Tokens.size());
}

void CPhrasesGenerator::ParseTokensFromFile(const char* pszLangFileBase, const char* pszLanguage)
{
	if (m_bReqTerm) {
		return;
	}

	char relativePath[PLATFORM_MAX_PATH];
	smutils->Format(relativePath, sizeof(relativePath), "resource/%s_%s.txt", pszLangFileBase, pszLanguage);

	m_Out << "\t// Input file: " << relativePath << "\n";

	char error[256];
	ParseError_t parseError = g_pLanguageFileParser->ParseFile(relativePath, this, error, sizeof(error));
	if (parseError == ParseError_None) {
		return;
	}

	if (parseError != ParseError_StreamOpen) {
		DevWarning("'%s': %s\n", relativePath, error);
	}
}
